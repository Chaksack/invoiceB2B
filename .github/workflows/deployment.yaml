name: CI/CD with ECS Deployment & Approval

on:
  push:
    branches:
      - staging
  pull_request:
    branches:
      - staging
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  id-token: write   # Required for AWS OIDC authentication
  pull-requests: write # For SonarQube comments or PR labels

jobs:
  lint-and-test:
    name: Lint, Test & Scan PR
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for SonarQube for full analysis history

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23' # As per your latest workflow

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Run linter (Placeholder)
        run: |
          echo "INFO: Linting step placeholder. Replace with your actual linting commands."
          # Example for golangci-lint:
          # curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.57.2
          # $(go env GOPATH)/bin/golangci-lint run ./...
          exit 0 # Simulate success

      - name: Run tests (Placeholder)
        run: |
          echo "INFO: Testing step placeholder. Replace with your actual test commands."
          # Example:
          # go test -v -race -coverprofile=coverage.out ./...
          exit 0 # Simulate success

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v2.0.0
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          # SONAR_PROJECT_KEY: "your_project_key" # Optional
          # SONAR_ORGANIZATION: "your_organization_key" # Optional

  notify-pr-review-needed:
    name: Notify PR Review Needed
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    steps:
      - name: Get short SHA for PR head
        id: short_sha_pr
        run: echo "sha=$(echo ${{ github.event.pull_request.head.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: Send Slack Notification for PR Review
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "PR opened by `${{ github.actor }}` needs review: <${{ github.event.pull_request.html_url }}|#${{ github.event.pull_request.number }} ${{ github.event.pull_request.title }}>",
              "blocks": [
                {
                  "type": "section",
                  "text": { "type": "mrkdwn", "text": "👀 *Pull Request Needs Review*\nPR <${{ github.event.pull_request.html_url }}|#${{ github.event.pull_request.number }} \"${{ github.event.pull_request.title }}\"> by `${{ github.actor }}` is ready for review." }
                },
                {
                  "type": "context",
                  "elements": [
                    { "type": "mrkdwn", "text": "Repository: `${{ github.repository }}`" },
                    { "type": "mrkdwn", "text": "Branch: `${{ github.event.pull_request.head.ref }}`" },
                    { "type": "mrkdwn", "text": "Commit: `${{ steps.short_sha_pr.outputs.sha }}`" }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  build-and-push-api-to-ecr:
    name: Build & Push API Image to ECR
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/staging' # Corrected branch
    needs: []
    environment:
      name: production # Ensure this environment is configured in GitHub Settings
      # The 'url' field for an environment cannot directly use the 'secrets' context.
      # This URL is a static link to the ECR console.
      # You can construct a more specific URL (with region, account, repo, tag) in a later step
      # and use it for notifications if needed.
      url: https://console.aws.amazon.com/ecr/repositories
    outputs:
      ecr_image_uri_api: ${{ steps.build-image-api.outputs.ecr_image_uri }}
      image_tag: ${{ steps.build-image-api.outputs.image_tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Extract AWS Account ID from Role ARN
        id: extract-account-id
        run: |
          ACCOUNT_ID=$(echo "${{ secrets.AWS_ROLE_TO_ASSUME }}" | cut -d':' -f5)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          if [ -z "$ACCOUNT_ID" ]; then
            echo "Error: Could not parse AWS_ACCOUNT_ID from AWS_ROLE_TO_ASSUME."
            exit 1
          fi

      - name: Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push API image to Amazon ECR
        id: build-image-api # Corrected step ID was 'build-image' in original URL, now 'build-image-api'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY_API: ${{ secrets.ECR_REPOSITORY_API }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building API Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG -f Dockerfile .
          echo "Pushing API Docker image to ECR: $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG"
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG
          echo "ecr_image_uri=$ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Successfully pushed $ECR_REGISTRY/$ECR_REPOSITORY_API:$IMAGE_TAG"

  deploy-to-ecs:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/staging' # Corrected branch
    needs: build-and-push-api-to-ecr
    environment:
      name: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME_ECS_DEPLOY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          yq --version

      - name: Prepare ECS-specific Docker Compose file
        id: prepare-compose
        env:
          API_IMAGE_URI: ${{ needs.build-and-push-api-to-ecr.outputs.ecr_image_uri_api }}
          DB_HOST_SECRET_ARN: ${{ secrets.DB_HOST_SECRET_ARN }}
          DB_PORT_SECRET_ARN: ${{ secrets.DB_PORT_SECRET_ARN }}
          DB_USER_SECRET_ARN: ${{ secrets.DB_USER_SECRET_ARN }}
          DB_PASSWORD_SECRET_ARN: ${{ secrets.DB_PASSWORD_SECRET_ARN }}
          DB_NAME_SECRET_ARN: ${{ secrets.DB_NAME_SECRET_ARN }}
          REDIS_HOST_SECRET_ARN: ${{ secrets.REDIS_HOST_SECRET_ARN }}
          REDIS_PORT_SECRET_ARN: ${{ secrets.REDIS_PORT_SECRET_ARN }}
          RABBITMQ_HOST_SECRET_ARN: ${{ secrets.RABBITMQ_HOST_SECRET_ARN }}
          RABBITMQ_PORT_SECRET_ARN: ${{ secrets.RABBITMQ_PORT_SECRET_ARN }}
          RABBITMQ_USER_SECRET_ARN: ${{ secrets.RABBITMQ_USER_SECRET_ARN }}
          RABBITMQ_PASS_SECRET_ARN: ${{ secrets.RABBITMQ_PASS_SECRET_ARN }}
          INTERNAL_API_KEY_SECRET_ARN: ${{ secrets.INTERNAL_API_KEY_SECRET_ARN }}
          N8N_ENCRYPTION_KEY_SECRET_ARN: ${{ secrets.N8N_ENCRYPTION_KEY_SECRET_ARN }}
          EFS_ID_UPLOADS: ${{ secrets.EFS_ID_UPLOADS }}
          EFS_ID_N8N_DATA: ${{ secrets.EFS_ID_N8N_DATA }}
          EFS_ID_SONAR_DATA: ${{ secrets.EFS_ID_SONAR_DATA }}
          EFS_ID_SONAR_LOGS: ${{ secrets.EFS_ID_SONAR_LOGS }}
          EFS_ID_SONAR_EXT: ${{ secrets.EFS_ID_SONAR_EXT }}
          APP_PORT_ENV: ${{ secrets.APP_PORT || '3000' }}
          N8N_WEBHOOK_URL_ENV: ${{ secrets.N8N_WEBHOOK_URL }}
          SONARQUBE_DB_NAME_ENV: ${{ secrets.SONARQUBE_DB_NAME || 'sonarqube_db' }}
          AWS_REGION_ENV: ${{ secrets.AWS_REGION }}
          LOG_GROUP_NAME_ENV: "/ecs/${{ secrets.ECS_PROJECT_NAME || 'invoiceb2b' }}" # Default project name if secret not set
          COMPOSE_PROJECT_NAME_ENV: ${{ secrets.ECS_PROJECT_NAME || 'invoiceb2b' }} # For N8N GO_API_BASE_URL
          AWS_VPC_ID_SECRET_ARN_ENV: ${{ secrets.AWS_VPC_ID_SECRET_ARN }} # Pass VPC ID secret ARN
        run: |
          echo "Preparing docker-compose.ecs.yml from docker-compose.yml..."
          cp docker-compose.yml docker-compose.ecs.yml

          yq -i 'del(.services.postgres)' docker-compose.ecs.yml
          yq -i 'del(.services.redis)' docker-compose.ecs.yml
          yq -i 'del(.services.rabbitmq)' docker-compose.ecs.yml
          yq -i 'del(.volumes.postgres_data)' docker-compose.ecs.yml
          yq -i 'del(.volumes.redis_data)' docker-compose.ecs.yml
          yq -i 'del(.volumes.rabbitmq_data)' docker-compose.ecs.yml

          yq -i '.services.api.image = env(API_IMAGE_URI)' docker-compose.ecs.yml
          yq -i 'del(.services.api.build)' docker-compose.ecs.yml
          yq -i 'del(.services.api.container_name)' docker-compose.ecs.yml
          yq -i 'del(.services.api.depends_on)' docker-compose.ecs.yml
          yq -i 'del(.services.api.env_file)' docker-compose.ecs.yml
          yq -i '.services.api.logging.driver = "awslogs"' docker-compose.ecs.yml
          yq -i '.services.api.logging.options."awslogs-group" = env(LOG_GROUP_NAME_ENV)' docker-compose.ecs.yml
          yq -i '.services.api.logging.options."awslogs-region" = env(AWS_REGION_ENV)' docker-compose.ecs.yml
          yq -i '.services.api.logging.options."awslogs-stream-prefix" = "api"' docker-compose.ecs.yml
          yq -i '.services.api.environment = [{"APP_ENV": "production"}, {"APP_PORT": env(APP_PORT_ENV)}]' docker-compose.ecs.yml
          yq -i '.services.api.secrets = [
            {"source": env(DB_HOST_SECRET_ARN), "target": "DB_HOST"},
            {"source": env(DB_PORT_SECRET_ARN), "target": "DB_PORT"},
            {"source": env(DB_USER_SECRET_ARN), "target": "DB_USER"},
            {"source": env(DB_PASSWORD_SECRET_ARN), "target": "DB_PASSWORD"},
            {"source": env(DB_NAME_SECRET_ARN), "target": "DB_NAME"},
            {"source": env(REDIS_HOST_SECRET_ARN), "target": "REDIS_ADDR"},
            {"source": env(REDIS_PORT_SECRET_ARN), "target": "REDIS_PORT_ONLY"},
            {"source": env(RABBITMQ_HOST_SECRET_ARN), "target": "RABBITMQ_HOST"},
            {"source": env(RABBITMQ_PORT_SECRET_ARN), "target": "RABBITMQ_PORT"},
            {"source": env(RABBITMQ_USER_SECRET_ARN), "target": "RABBITMQ_USER"},
            {"source": env(RABBITMQ_PASS_SECRET_ARN), "target": "RABBITMQ_PASS"},
            {"source": env(INTERNAL_API_KEY_SECRET_ARN), "target": "INTERNAL_API_KEY"}
          ]' docker-compose.ecs.yml
          yq -i '.services.api.volumes = [{"type": "volume", "source": "efs_uploads", "target": "/mnt/invoice_uploads"}]' docker-compose.ecs.yml

          yq -i 'del(.services.n8n.container_name)' docker-compose.ecs.yml
          yq -i 'del(.services.n8n.depends_on)' docker-compose.ecs.yml
          yq -i '.services.n8n.logging.driver = "awslogs"' docker-compose.ecs.yml
          yq -i '.services.n8n.logging.options."awslogs-group" = env(LOG_GROUP_NAME_ENV)' docker-compose.ecs.yml
          yq -i '.services.n8n.logging.options."awslogs-region" = env(AWS_REGION_ENV)' docker-compose.ecs.yml
          yq -i '.services.n8n.logging.options."awslogs-stream-prefix" = "n8n"' docker-compose.ecs.yml
          yq -i ".services.n8n.environment.GO_API_BASE_URL = \"http://api.${COMPOSE_PROJECT_NAME_ENV}.internal:${APP_PORT_ENV}/api/v1\"" docker-compose.ecs.yml
          yq -i '.services.n8n.environment.N8N_ENCRYPTION_KEY = ""' docker-compose.ecs.yml # Clear it, will use secret
          yq -i '.services.n8n.secrets = [{"source": env(N8N_ENCRYPTION_KEY_SECRET_ARN), "target": "N8N_ENCRYPTION_KEY"}]' docker-compose.ecs.yml
          yq -i '.services.n8n.environment.WEBHOOK_URL = env(N8N_WEBHOOK_URL_ENV)' docker-compose.ecs.yml
          yq -i '.services.n8n.volumes = [
            {"type": "volume", "source": "efs_n8n_data", "target": "/home/node/.n8n"},
            {"type": "volume", "source": "efs_uploads", "target": "/mnt/invoice_uploads"}
          ]' docker-compose.ecs.yml

          yq -i 'del(.services.sonarqube.container_name)' docker-compose.ecs.yml
          yq -i 'del(.services.sonarqube.depends_on)' docker-compose.ecs.yml
          yq -i '.services.sonarqube.logging.driver = "awslogs"' docker-compose.ecs.yml
          yq -i '.services.sonarqube.logging.options."awslogs-group" = env(LOG_GROUP_NAME_ENV)' docker-compose.ecs.yml
          yq -i '.services.sonarqube.logging.options."awslogs-region" = env(AWS_REGION_ENV)' docker-compose.ecs.yml
          yq -i '.services.sonarqube.logging.options."awslogs-stream-prefix" = "sonarqube"' docker-compose.ecs.yml
          yq -i ".services.sonarqube.environment.SONAR_JDBC_URL = \"jdbc:postgresql://\${SONAR_DB_HOST}:\${SONAR_DB_PORT}/${SONARQUBE_DB_NAME_ENV}\"" docker-compose.ecs.yml
          yq -i '.services.sonarqube.secrets = [
            {"source": env(DB_HOST_SECRET_ARN), "target": "SONAR_DB_HOST"},
            {"source": env(DB_PORT_SECRET_ARN), "target": "SONAR_DB_PORT"},
            {"source": env(DB_USER_SECRET_ARN), "target": "SONAR_JDBC_USERNAME"},
            {"source": env(DB_PASSWORD_SECRET_ARN), "target": "SONAR_JDBC_PASSWORD"}
          ]' docker-compose.ecs.yml
          yq -i '.services.sonarqube.volumes = [
            {"type": "volume", "source": "efs_sonarqube_data", "target": "/opt/sonarqube/data"},
            {"type": "volume", "source": "efs_sonarqube_logs", "target": "/opt/sonarqube/logs"},
            {"type": "volume", "source": "efs_sonarqube_extensions", "target": "/opt/sonarqube/extensions"}
          ]' docker-compose.ecs.yml

          yq -i '.volumes.efs_uploads.driver = "local" | .volumes.efs_uploads."x-aws-volume".efs.file_system_id = env(EFS_ID_UPLOADS)' docker-compose.ecs.yml
          yq -i '.volumes.efs_n8n_data.driver = "local" | .volumes.efs_n8n_data."x-aws-volume".efs.file_system_id = env(EFS_ID_N8N_DATA)' docker-compose.ecs.yml
          yq -i '.volumes.efs_sonarqube_data.driver = "local" | .volumes.efs_sonarqube_data."x-aws-volume".efs.file_system_id = env(EFS_ID_SONAR_DATA)' docker-compose.ecs.yml
          yq -i '.volumes.efs_sonarqube_logs.driver = "local" | .volumes.efs_sonarqube_logs."x-aws-volume".efs.file_system_id = env(EFS_ID_SONAR_LOGS)' docker-compose.ecs.yml
          yq -i '.volumes.efs_sonarqube_extensions.driver = "local" | .volumes.efs_sonarqube_extensions."x-aws-volume".efs.file_system_id = env(EFS_ID_SONAR_EXT)' docker-compose.ecs.yml
          
          yq -i '.x-aws-vpc = env(AWS_VPC_ID_SECRET_ARN_ENV)' docker-compose.ecs.yml

          echo "--- Generated docker-compose.ecs.yml ---"
          cat docker-compose.ecs.yml
          echo "----------------------------------------"
          echo "compose_file_path=docker-compose.ecs.yml" >> $GITHUB_OUTPUT

      - name: Deploy to ECS using Docker CLI
        env:
          COMPOSE_PROJECT_NAME: ${{ secrets.ECS_PROJECT_NAME || 'invoiceb2b' }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ECS_CLUSTER_NAME: ${{ secrets.ECS_CLUSTER_NAME }}
        run: |
          echo "Deploying services from ${{ steps.prepare-compose.outputs.compose_file_path }} to ECS cluster: ${ECS_CLUSTER_NAME}"
          docker ecs compose --cluster ${ECS_CLUSTER_NAME} --aws-region ${AWS_REGION} \
            -f ${{ steps.prepare-compose.outputs.compose_file_path }} \
            --project-name ${COMPOSE_PROJECT_NAME} up
          echo "ECS deployment initiated. Monitor progress in AWS Console (ECS & CloudFormation)."

  notify-deployment-status:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/staging' # Corrected branch
    needs: [build-and-push-api-to-ecr, deploy-to-ecs]
    steps:
      - name: Get short SHA for main push
        id: short_sha_main
        run: echo "sha=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: Send Slack Notification for Deployment Status
        uses: slackapi/slack-github-action@v1.26.0
        with:
          payload: |
            {
              "text": "${{ needs.deploy-to-ecs.result == 'success' && '✅ ECS Deployment Successful' || (needs.build-and-push-api-to-ecr.result != 'success' && '❌ API Image Build/Push Failed' || '❌ ECS Deployment Failed') }} for `${{ github.repository }}`",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ needs.deploy-to-ecs.result == 'success' && '✅ *ECS Deployment Successful*' || (needs.build-and-push-api-to-ecr.result != 'success' && '❌ *API Image Build/Push Failed*' || '❌ *ECS Deployment Failed*') }}\nRepository: `${{ github.repository }}`\nBranch: `${{ github.ref_name }}`"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    { "type": "mrkdwn", "text": "Commit: <${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}|`${{ steps.short_sha_main.outputs.sha }}`>" },
                    { "type": "mrkdwn", "text": "Triggered by: `${{ github.actor }}`" },
                    { "type": "mrkdwn", "text": "API ECR Image: `${{ needs.build-and-push-api-to-ecr.outputs.ecr_image_uri_api || 'N/A' }}`" },
                    { "type": "mrkdwn", "text": "Workflow Run: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>" }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
